//
// Pure Go implementation of the Matrix arithmetic and GSL libs
// draft version
// unstable API
//
// Solvers and Numerical methods
//
// This module provides tools to optimization, searching miminimu/maximum,
// linear equation system solvers, numerical differentiation and so on...
//
package matrix_arithmetic

// TODO: Unified Interface for v.2

import(
	// common purpose
	"fmt"
	_ "bufio"
	_ "os"
	_ "io"
	_ "strings"
	_ "strconv" // aoti and so on convertions
	"errors" // errors.New()
	"math"
	_ "log"
	_ "time"
//	"sync"
)


const(
	MAXITERATIONS = 10//10000
)


/*
 *  solvers */


/* solve linear equation */
// export
func Solve(x *Matrix, a *Matrix, b *Matrix, epsilon float64) (float64,error) {
	/* solves linear equation Ax = b for x using Matrix
 	 * inversion NOTE: no explicit error checking; (except for
 	 * allocation failures) all potential errors are checked in 
 	 * called functions */
	var det float64 = float64(0)

	/* allocate a Matrix to invert */
	ainv, err := New(a.rows, a.cols)
	if err != nil {
		return det,err
	}

	// inverse Matrix
	det, err = Inverse(ainv, a, epsilon)
	if err != nil {
		return det,err
	}

	// solve equeation
	Mult(x, ainv, b);

	return det,nil;
}


/* solve linear equation with error correction */
// export
func Ecsolve(x *Matrix, a *Matrix, b *Matrix, epsilon float64) (float64,error) {
	/* solves linear equation Ax = b for x using Matrix
	 * inversion and a followup iterative approach for error
	 * correction */
	var ainv *Matrix = nil
	var bprime *Matrix = nil
	var adj *Matrix = nil
	var newx *Matrix = nil
	var newadj *Matrix = nil
	var merr *Matrix = nil
	var adjenorm float64
	var newadjenorm float64
	var det float64 = float64(0)

	ainv, err := New(a.rows, a.cols)
	if err != nil {
		return det,errors.New(ALLOCFAIL)
	}

	bprime, err = New(b.rows, b.cols)
	if err != nil {
		return det,errors.New(ALLOCFAIL)
	}

	adj, err = New(x.rows, x.cols)
	if err != nil {
		return det,errors.New(ALLOCFAIL)
	}

	newx, err = New(x.rows, x.cols)
	if err != nil {
		return det,errors.New(ALLOCFAIL)
	}

	newadj, err = New(adj.rows, adj.cols)
	if err != nil {
		return det,errors.New(ALLOCFAIL)
	}

	merr, err = New(x.rows, x.cols)
	if err != nil {
		return det,errors.New(ALLOCFAIL)
	}

    /* calculate the first try at a solution including
     * calculation of first adjustment */
    det, err = Inverse(ainv, a, epsilon)
	if err != nil {
		return det, err
	}

	Mult(x, ainv, b)
	Mult(bprime, a, x)
	Sub(merr, b, bprime)
	Mult(adj, ainv, merr)

	adjenorm,_ = E_Norm(adj)


	/* iteratively calculate new solutions while accuracy
	 * improves do no more than 10 iterations to prevent a
	 * runaway calculation */
	stop := false
	for iteration := 0; iteration < 10/*MAXITERATIONS*/ && !stop; iteration++ {
		Add(newx, x, adj)
		Mult(bprime, a, newx)
		Sub(merr, b, bprime)
		Mult(newadj, ainv, merr)
		newadjenorm, _ = E_Norm(newadj)
		/* this is a test to see if complete else clause
		 * operates to break out of loop if no improvement
		 * since previous iteration; otherwise try again */
		if (newadjenorm < adjenorm) {  /* still improving */
			adjenorm = newadjenorm
			Assign(x, newx)
			Assign(adj, newadj)
		} else {
			/* stop calculating */
			stop = true
		}
	}

	// success
	return det,nil
}


/* 
 * simplex */

//TODO: приведение к канонической форме
// получение из прямой задачи двойственной(чтобы искать всегда максимум)
// формирование двойственной задачи для прямой
// решение двойственной зачи
// проверка условия оптимальности
func SimplexSolve(A *Matrix) {

	// Элементы симплекс-таблицы A=ǁaijǁ вычисляются по формулам:
	// q - разрешающая строка
	// p - разрешающей столбец
	// aqp - разрешающий элемент(pivot)
	//        / aqj/aqp; i = q
	//        | aij + (-aip)*aqj/aqp; i ≠ q
	// aij = <  i = 0..m; j = 0..n
	//        | am+1j = -cj
	//        | ain+1 = bi
	//        \ am+1n+1 = L

	//Инициализация
	tempA,_ := New(A.Rows(), A.Cols())

	Mprintf("## START A", "%.2f ", A)
	// Шаг 1: Выполняется проверка полученного базисного плана на оптимальность по условию: 
	// если при каком-либо ДБР (допустимое базисное решение) в симплекс-таблице все коэффициенты 
	// строки f(x) (то есть -cj) не отрицательны,
	// то данное ДБР оптимально, следовательно КОНЕЦ решения. 
	optimum := testoptimum(A)

	//В противном случае:
	for iteration := 0; iteration < MAXITERATIONS && !optimum; iteration++ {

		fmt.Println("iteration:", iteration)
		//fmt.Println("BEGIN")

		// Симплекс-метод. Выбор ведущего столбца
		// Шаг 2: Переход к новому базисному плану. 
		// Для этого из числа небазисных переменных с отрицательными значениями в последней строке 
		// (то есть -cj < 0) выбирается переменная, вводимая в базис – xp, 
		// это переменная которой соответствует наибольшая по модулю 
		// отрицательная оценка:
		// cp = max(abs(cj), cj < 0
		// или 
		// cp = min cj
		// Столбец, отвечающий переменной xp, называется главным, или ведущим. 
		// Элементы данного столбца обозначаются через aip.
		// Если окажется несколько одинаковых наибольших по модулю отрицательных оценок,
		// то выбирается любая из соответственных переменных.
		cMin,pivotCol := Min(A, A.Rows()-1, ROWVECTOR)
		fmt.Printf("c min: %.2f\n", cMin)


		// Симплекс-метод. Выбор ведущей строки
		// Шаг 3: Выбираем переменную r – переменную, которая выводится из базиса. 
		// Данная переменная находится из соотношения:
		// bp/aqp = minj  bi/aip, aip > 0, j = p = const
		factorMin,pivotRow := minfactor(A, pivotCol)
		fmt.Printf("factor min: %.2f\n", factorMin)


		// Строка таблицы, в которой получено наименьшее отношение элемента столбца «В» 
		// к соответствующему положительному элементу ведущего столбца, является ведущей, или главной.
		// Элементы главной строки обозначаются через aqj. 
		// Выбранная переменная xr будет выводиться из базиса, то есть это исключаемая переменная.
		// Если окажется несколько одинаковых наименьших значений отношений,
		// то выбирается любая из соответствующих им переменных.
		// Элемент, который стоит на пересечении главного столбца и строки называется главным, 
		// или ведущим, и обозначается aqp.
		pivot,_ := A.Getij(pivotRow, pivotCol)
		fmt.Printf("pivot row: %d\n", pivotRow)
		fmt.Printf("pivot col: %d\n", pivotCol)
		fmt.Printf("pivot[%d,%d]: %.2f\n", pivotRow, pivotCol, pivot)


		// Шаг 4: Для определения нового базисного плана проводится пересчет элементов симплекс-таблицы,
		// и результаты заносятся
		// в новую таблицу. Выбранные переменные среди базисных и не базисных, 
		// лежащих на главной строке и главном столбце, меняются местами.
		// Процедура пересчета элементов выполняется следующим образом:
		// а) элементы главной строки необходимо разделить на ведущий элемент:
		// Замена базиса. Пересчет ведущей строки
		// bq = bp/aqp
		// aqj = aqj/aqp
		for j := 0; j < A.Cols(); j++ {
			aqj,_ := A.Getij(pivotRow, j)
			new_aqj := aqj / pivot
			tempA.Setij(pivotRow, j, new_aqj)
		}
		Mprintf("##", "%.2f ", tempA)
		// б) элементы полученной строки умножаются на -aip, и результаты складываются с i-той строкой,
		// причем i ≠ q:
		// Замена базиса. Пересчет элементов
		// new_aij = aij + (-aip) * aqj/aqp 
		// new_bi = bi + (-aip) * bq/aqp
		// new_cj = cj + (-cp) * aqj/aqp
		// new_L = L + (-cp) * bq/aqp
		for i := 0; i < A.Rows(); i++ {
			for j := 0; j < A.Cols(); j++ {
				if i ==  pivotRow {
					continue
				} else {
					aij,_ := A.Getij(i, j)
					aip,_ := A.Getij(i, pivotCol)
					factor,_ := tempA.Getij(pivotRow, j)
					new_aij := aij + float64(-1) * aip * factor
					tempA.Setij(i, j, new_aij)
				}
			}
		}


		// Получить новую симплекс-таблицу 
		Assign(A, tempA)


		// Отбразить симплекс-таблицу
		Mprintf("## ITER A", "%.2f ", A)
		//fmt.Println("END")
		//fmt.Println()
		//fmt.Println()


		// После определения новой симплекс-таблицы переходят к шагу 1.
		optimum = testoptimum(A)
	} // eof for interation

	// отобразить симлекс таблицу с решением прямой задачи
	Mprintf("\n## A", "%.2f ", A)

	//TODO: Используя последнюю итерацию прямой задачи найдем, оптимальный план двойственной задачи.
	// Из теоремы двойственности следует, что Y = C * A-1.
	// Обратите внимание, обратная матрица A-1 расположена в столбцах дополнительных переменных 
	// окончательного варианта симплекс-таблицы.

	// Проверим критерий оптимальности полученного решения.
	// Если существуют такие допустимые решения X и Y прямой и двойственной задач, 
	// для которых выполняется равенство целевых функций F(x) = Z(y), 
	// то эти решения X и Y являются оптимальными решениями прямой и двойственной задач соответственно.
	// [https://math.semestr.ru/simplex/msimplex.php]
}



/**
 ** Internals
 */

//FIXME: in haste 

/* function to devide bi limitations by pivot colum aip elements
   and find min factor */
func minfactor(a *Matrix, pivotCol int) (float64,int) {
	var factorMin float64
	var minIndex int

	bi,_ := a.Getij(0, a.Cols()-1)
	aip,_ := a.Getij(0, pivotCol)

	if aip < float64(0) {
		aip = math.Inf(1) // +oo
		factorMin = math.Inf(1)
	} else {
		factorMin = bi / aip
	}
	minIndex = 0
	for i := 1; i < a.Rows(); i++ {
		aip,_ = a.Getij(i, pivotCol)
		if aip > float64(0) {
			bi,_ = a.Getij(i, a.Cols()-1)
			factor :=  bi / aip
			if factorMin > factor {
				factorMin = factor
				minIndex = i
			}
		}
	}

	return factorMin,minIndex
}


/*TODO: let's test maybe the tab is optimal? */
func testoptimum(a *Matrix) bool {
	var optimum bool = true
	var stop bool = false

	// Для проверки на оптимальность просматривается последняя f – строка.
	//
	// a ) Если коэффициенты, стоящие при свободных переменных неотрицательны, то
	//     полученное решение оптимально. Решение единственно, если все коэффициенты положительны. 
	//     Если хотя бы один нулевой - бесконечное множество решений.
	//
  // b) Если хотя бы один коэффициент < 0, а в соответствующем столбце нет ни одного
	//    положительного элемента, то целевая функция f не ограничена.
	//
	// c) Если хотя бы один коэффициент отрицателен, а в соответствующем стобце есть
	//    положительные элементы, то полученное решение может быть улучшено.
	//
	// В последней строке a[m+1,j] содержится коэффициенты при переменных целевой функции
	for j := 0; j < a.Cols() && !stop; j++ {
		cj,_ := a.Getij(a.Rows()-1, j)
		fmt.Printf("  c[%d]: %f\n", j, cj)
		if cj < 0 {
			hasAtLeastOnePositiveItem := false
			for i := 0; i < a.Rows(); i++ {
				aij,_ := a.Getij(i, j)
				fmt.Printf("    a[%d,%d]: %f", i, j, aij)
				if aij > 0 {
					fmt.Printf(" positive")
					hasAtLeastOnePositiveItem = true
				}
				fmt.Printf("\n")
			}
			if hasAtLeastOnePositiveItem {
			// is not an optimum
				fmt.Printf("  IS NOT OPTIMAL\n")
				optimum = false
			} else {
			// f(x) has no limits
				fmt.Printf("  HAS NO LIMITS\n")
				optimum = true
			}
		}
	}
	fmt.Printf("  optimum: %d\n", optimum)
	return optimum
}


// подготовить задачу для решения из исходных
func simplex_prepare() {
/*
	Исходные данные для задачи:
	m - число уравнений
	n - число неизвестных
	-количество ограничений m = M
	-количество переменных n = N
	-процедура min|max
	-коэффициенты при переменных целевой функции	
	-матрица коэффициентов при не базисных переменных из ограничений задачи
	-знаки для огнаничений системы неравенств LE(<=)|EQ(==)|ME(>=)
	-правая часть ограничений системы неравенств
*/
	// матрица коэффициентов при не базисных переменных из ограничений задачи m x n
	// скаляр процедура
	// вектор коэффициенты при переменных целевой функции n
	// вектор знаков ограничений n
	// вектор свободных членов ограничений m
/*
	Пример:

	Прямая задача
	L =	3000x1 + 2400x2 → max

	2.1x1 + 0.6x2 <= 900	
	20x1 + 2x2 <=  8000	
	1x1 + 1x2 <= 1000	

	Каноничный вид:
	2.1x1 + 0.6x2 + 1x3 + 0x4 + 0x5 = 900	
	20x1 + 2x2 + 0x3 + 1x4 + 0x5 = 8000	
	1x1 + 1x2 + 0x3 + 0x4 + 1x5 = 1000	
	-3000x1 - 2400x2 + 0x3 + x04 + 0x5 = 0	

	затем составляют симплекс-таблицу вида:
	Симплекс-метод. Симплекс-таблица, где в столбце «базис» казываются базисные переменные, а в последней строке столбца «базис» пишется f(x) = L. 
	В столбец «B» записываются свободные члены ограничений bi и значение целевой функции (на 1-м этапе оно равно 0, т.е. никакой прибыли).

	В столбцах xj для не базисных переменных указываются коэффициенты при не базисных переменных из ограничений задачи. 
	2.1 0.6
	20  2   
	1   1  

	В столбцах базисных переменных содержится только 0 или 1 на пересечении столбца с соответствующей строкой базисной переменной.
	1 0 0
	0 1 0
	0 0 1

	В последней строке -cj – это коэффициенты при переменных целевой функции взятые с противоположным знаком.
	−3000 −2400 0 0 0 

	Матрица коэффициентов X системы уравнений имеет вид:
	2.1 0.6 
	20  2  
	1   1   

	Правая часть свобоных членов B ограничений системы уравнений имеет вид:
	900
	8000
	1000
	0

	Коэффициеты C целевой фунции и нули в столбцах базисных переменных и в ячейке целевой фукнции L
	−3000 −2400 0 0 0 

	Симплекс-таблица составлена A=ǁaijǁ, теперь опишем сам симплекс-метод.
	 2.1   0.6  1 0 0 900
	 20    2    0 1 0 8000
	 1     1    0 0 1 1000
	−3000 −2400 0 0 0 0
*/

/*
	ОЗЛП не всегда имеет решение.
	1. Уравнения могут оказаться несовместными.
	2. Уравнения совместны не в области неотрицательных решений.
	3. допустимые решения существуют, но среди них нет оптимального:
	функция f не ограничена в области оптимальных решений.
	Замечание: систему (1) имеет смысл решать, если число уравнений в системе меньше
	числа неизвестных m < n.
	Если m = n , решение системы единственно и задача по максимизации функции не
	имеет смысла;
	Если m > n, то система переопределена и в общем случае не имеет решений;
	m < n – система имеет бесконечное множество решений и среди них можно выбрать
	оптимальное, доставляющее максимум функции.

	Рассмотрим Пример 1.
	Имеется 2 уравнения и 4 неизвестных. Можно 2 неизвестных сделать произвольны-
	ми и решать систему относительно 2-х оставшихся переменных. Если при этом мы при-
	равниваем 2 свободных неизвестных 0, то получаем единственное решение, которое назы-
	вается базисным. Если оно является допустимым, то базисным допустимым решением.
	В общем случае имеется n переменных и m ограничений (m < n). Приравниваем к
	нулю n – m переменных. Они являются небазисными. Т. е свободные переменные.
	Таким образом, m – базисных переменных, n – m – свободных.
*/

/*
	Симплекс-таблица A = ǁaijǁ составлена.

	Элементы симплекс-таблицы A = ǁaijǁ вычисляются по формулам:
	q - разрешающая строка
	p - разрешающей столбец
	aqp - разрешающий элемент(pivot)

				 / aqj/aqp; i = q
				 | aij + (-aip)*aqj/aqp; i ≠ q
	aij = <  i = 0..m; j = 0..n
				 | am+1j = -cj
				 | ain+1 = bi
				 \ am+1n+1 = L

	Симпелкс таблица:

	Где в столбце «базис» казываются базисные переменные, 
	В столбец a[i,n+1] «B» записываются свободные члены ограничений bi 
	и значение целевой функции (на 1-м этапе оно равно 0, т.е. никакой прибыли).

	В последней строке a[m+1,n+1] столбца «базис» пишется значение целевой функции f(x) = L. 

	В столбцах a[0..m,0..n] для не базисных переменных xj указываются 
	коэффициенты при не базисных переменных из ограничений задачи. 

	В столбцах a[0..m,n..n+m] базисных переменных содержится только 0 или 1 
	на пересечении столбца с соответствующей строкой базисной переменной.

	В последней строке a[m+1,j] содержится -cj – это коэффициенты при переменных целевой функции взятые с противоположным знаком.

*/

/* 
	В начале исходную задачу линейного программирования приводят к каноническому виду, 
	f = c1x1 + c2x2 + ... + cnxn →  max
	 
	 / a11x1 + ... + a1nxn <= b1
	 | a21x1 + ... + a12nxn <=b2
	<      ......
	 | am1x1 + ... + amnxn <= bm
	 \ x1,x2,...,xn >= 0

	        / cT * x →  max
	Прямая <  A * x <= b
	        \ x >= 0 


	g = b1y1 + b2, + ... + bnyn →  min

	 / a11y1 + ... + a1mym <= c1
	 | a21y1 + ... + a12mym <=c2
	<      ......
	 | an1x1 + ... + anmym <= cn
	 \ y1,y2,...,ym >= 0

	              / bT * y →  min
	Двойственная <  AT * y >= c
	              \ y >= 0

	Порядок приведения к каноческому виду

	Все задачи линейного программирования могут быть приведены к стандартной
	форме, в которой целевая функция должна быть максимизирована, а все ограничения
	должны быть заданы в виде равенств с неотрицательными переменными. Такая стандарт-
	ная форма (каноническая) называется ОЗЛП

	1) Случай обращения в min сводится к предыдущему, если взять L'= L.
	2) Ограничения в виде неравенства со знаком <= превращаются в равенство при
	добавлении в левую часть дополнительной неотрицательной переменной.
	Пример:
	3x1 + 2x2 - x3 <= 6
	3x1 + 2x2 - 1x3 + 1x4 = 6 ( x4 >= 0 )
	3) Ограничения, содержащие неравенство со знаком >= переходят к равенству вы-
	читая из левой части дополнительную неотрицательную переменную. 
	Пример:
	x1 - x2 + 3x3 >= 10
	x1 - x2 + 3x3 - 1x5 = 10 ( x5 >= 0 )
	4) Если некоторая переменная xk может принимать любые значения, а требуется
	xk >= 0, то ее можно привести к виду xk = x'k - x''k, где x'k >= 0 и x''k >= 0.
	Т.е. приведение задач к стандартной форме может потребовать введения дополни-
	тельных переменных. Они называются балансовыми.
*/


/*
	Алгоритм составления двойственной задачи.
	[https://studfiles.net/preview/2290830/]

	Исходдная прямая задача
	F = 1x1 + 2x2 -> max

	4x1 - 2x2 <= 12
	-1x1 + 3x2 <= 6
	2x1 + 4x2 >= 16
	x1,x2 => 0 

	Решение можно записать так:
	x1 = 4.8
	x2 = 3.6

	Значение целевой функции в данной точке:
	F = 1·4.8+2·3.6 = 12



	Соатвими двойственную задачу

	1.Приводим все неравенства системы ограничений исходной задачи к одному смыслу
		Для этого неравенства, в которых данное требование не выполняется, умножить на –1.
		4x1 - 2x2 <= 12
	 -1x1 + 3x2 <= 6
		(-1)*2x1 + (-1)(4x2 <= (-1)*16

	2.Составляем расширенную матрицу
		4 -2  12
	 -1  3  6
	 -2 -4 -16
		1  2

	3.Транспонируем матрицу
	 4 -1 -2  1
	-2  3 -4  2
	12  6 -16

	4.Формулируем двойственную задачу
	Z = 12y1 + 6y2 - 16y3 -> min

	4y1 - 1y2 - 2y3 >= 1
	-2y1 + 3y2 - 4y3 >= 2
	y1,y2,y3 >= 0


	1) Случай обращения в min сводится к предыдущему, если взять L'= L.
	Z = 12y1 + 6y2 + 16y3 -> min
	Z = L = -12y1 - 6y2 + 16y3 -> max

	4y1 - 1y2 - 2y3 =< 1
	-2y1 + 3y2 - 4y3 =< 2
	y1,y2,y3 >= 0

	Теперь приводим к каноническому виду, составляем симплекс таблицу и решаем в штатном порядке
	 4y1 - 1y2 - 2y3 + 1y4 + 0y5 = 1
	-2y1 + 3y2 - 4y3 + 0y4 + 1y5 = 2

	Симплекс таблица
	 4  -1 -2  1  0 1
	 -2  3 -4  0  1 2
	-12 -6 -16 0  0 0 

	Решаем симплекс методом
Запишем текущий опорный план:
X = 0 0 0 1 2
	
Значение целевой функции в данной точке:
F = −12·0−6·0+16·0+0·1+0·2 = 0
Самый большой по модулю отрицательный элемент (−16), следовательно в базис входит вектор y3.
Определяем, какой вектор выходит из базиса. 
Для этого вычисляем min(ai,0 /ai,3), при ai,3>0, i=1,...2. 
Все ai,3 ≤ 0, следовательно целевая функция неограничена сверху.

*/
/*
	Двойственная задача

	Смотри алгоритм в модуле solvers.go
	1)
	2.1x1 + 0.6x2 <= 900	
	20x1 + 2x2 <=  8000	
	1x1 + 1x2 <= 1000	

	2)
	2.1   0.6   900
	20    2     8000
	1     1     1000
	3000  2400

	3)
	2.1 20 1 3000
	0.6 2 1 2400
	900 8000 1000

	4)
	Z = 900y1 + 8000y2 + 1000y3 -> min

	2.1y1 + 20y2 + y3 >= 3000
	0.6y1 + 2y2 + y3 >= 2400

	FIXME: это надо перерешивать по этому методу!
	Симплекс-метод, решение задачи с искусственным базисом
	https://studfiles.net/preview/844616/page:2/
Далее походу не верно!!!
	Каноничнй вид:
	Случай обращения в min сводится к предыдущему, если взять L' = -L.
	L' = -900y1 - 8000y2 - 1000y3 -> max

	2.1y1 + 20y2 + 1y3 - 1y4 + 0y5 = 3000
	0.6y1 + 2y2 + 1y3 + 0y4 - 1y5 = 2400  

	таблица
	2.1     20.0    1.0    -1.0 0.0 3000.0
	0.6     2.0     1.0    0.0 -1.0 2400.0
	-900.0 -8000.0 -1000.0 0.0  0.0 0.0
*/
} // eof simplex_prepare






// Методы численного дифференцирования функций
// Метод двусторонней разности
// более точное приближение к искомому значению производной функции в точке x0  можно получить, 
// воспользовавшись формулами двусторонней разности:
//
// f'(x) = ( f(x0 + /\x) - f(x0 - /\x) ) / (2 * /\x)
//
// или, для функций заданных в виде выборки:
//
// f'i = ( f[i+1] - f[i-1] ) / (x[i+1] - x[i-1]) 
//
func function_derivative(function func (x float64) float64, x, delta float64) float64 {
	return ( function(x + delta) - function(x - delta) ) / (2.0 * delta)
}
//
//TODO:func sampled_function_derivative() {}

//
// Частное дифференцирование функции многих переменных
// В этом случае все аргументы функции становятся константами кроме аргумента, 
// по которому проводится дифференцирование, 
// а требуемый порядок производной получается путем последовательного вычисления производных, 
// вплоть до требуемого порядка:
// 
// df/dxi = f(x1,x2,...,xi+/\xi/2,...xn) - f(x1,x2,...xi-/\xi/2,...xn) / /\xi
//
// или
// 
// df/dxi = f(x1,x2,...,xi+/\xi,...xn) - f(x1,x2,...xi-/\xi,...xn) / (2 * /\xi)
//
//
// numerical differentiation
// Метод двусторонней разности
//
// операция grad или nabla
// Определить частные производные функции f(x):
// grad f(x) = [ df(x)/x1,...,df(x)/dxn ]T(транспонированный вектор)
// 
// Example:
//                      __
// grad F or nabla F or \/F
/*
func grad(function func (args []float64) float64, args []float64, delta float64) []float64 {
	// NOTE: delta ought to be small enough but you should remember 
	//       that too small value will drive to reducing accuracy
	//
	// df/dxi = f(x1,x2,...,xi+/\xi,...xn) - f(x1,x2,...xi-/\xi,...xn) / (2 * /\xi) 
	//
	gradient := make([]float64, len(args))
	for i := 0; i < len(gradient); i++ {
		left := make([]float64, len(args))
		copy(left, args)
		right := make([]float64, len(args))
		copy(right, args)
		left[i] += delta
		right[i] -= delta
		gradient[i] = ( function(left) - function(right) ) / (2.0 * delta)
	}
	return gradient
}
*/
// TODO:
// Производные высоких порядков
// При вычислении производных высоких порядков производная (n)-го порядка считается первой 
// производной от (n-1)-го порядка. Так вторая производная функции является первой производной 
// от первой производной:
//
// d2f/dx2 = d/dx(df/dx) = (f'1 - f'2 / 2/\x) = (f'2 - 2f'0 + f'-2) / (2 * /\x)^2
//
// [http://aco.ifmo.ru/el_books/numerical_methods/lectures/glava1.html]



//
// Optimization methods interface
//
// methods of one-dimensional and multidimensional optimization
type ODO interface {
	// отрезок для поиска минимума методом одной оптимизации
	//a,b float64
	GetInterval() (float64,float64)
	// максимальное количесво приближений 
	//n int - для одномерной оптимизации
	GetMaxIterODO() int
	// требуемая точность
	//epsilon1 float64 для метода одномерной оптимизации
	GetEpsilon1() float64
	// функция g(x) оценки минимума в методах одномерной оптимизации 
	// в методе наискорейшего спуска(вообще в многомерной оптимизации) это функция g(x[k]) 
	// применяемая для нахождения шага поиска lambda[k] как минимума функции g(x[k])
	// на отрезке a,b
	// lambda здесь это вычисленная точка по методу поиска минимума, имя надо бы выбрать другое... 
	GetG() func(data ODO, lambda float64) float64
	// вектор аргументов функции
	GetX() []float64
	SetX(args []float64)
	// фукнция миниму которой мы ищев в методах многомерной оптимизации
	Function() float64
	// значение фукнции
	SetY(float64)
	// градиет функции - вектор частных производных
	Grad() []float64
}

type MDO interface {
	ODO
	// максимальное количесво приближений 
	//m int - многомерной оптимизации
	GetMaxIterMDO() int
	// требуемая точность
	//epsilon2 float64 для метода многомерной оптимизации
	GetEpsilon2() float64
	// Аргумент минимизации (для наискорейшего спуска argmin по lambda)
	// phi(x) метод одномерной оптимизаци
	GetF() func(data ODO) float64
	//
	//TODO: Условие остановки:
	// Если |vec x[k+1] - vec x[k]| > epsilon
	//  или |F(vec x[k+1]) - F(vec x[k])| > epsilon
	//  или |nabla F(vec x[k+1])| > epsilon (выбирают одно из условий)
	//Norma()
}


// Метод половинного деления для нахождения минимума
// dichotomia — разделение на две части
func Dichotomia(data ODO) float64 {
	// Номер шага
	var k int
	// Отклонени от середины отрезка влево, вправо
	var left float64
	var right float64
	// критерий требуемой точности
	epsilon := data.GetEpsilon1()
	// Величина на которую мы отклонимся от середины отрезка
	var deviation float64 = 0.5 * epsilon
	// Точка минимума
	var x_min float64
	// Отрезок локализации минимума
	ak,bk := data.GetInterval()
	// функция g(x) оценки минимума в методах одномерной оптимизации на отрезке a,b 
	g := data.GetG()

	// Пока длина отрезка больше заданной точности
	niterations := data.GetMaxIterODO()
	for k = 1; (bk - ak) >= epsilon && k < niterations; k++ {
		// Берем середину (ну почти середину - +\- некоторое дельта 
		// в частности у нас deviation = 0.5 * epsilon)
		left = (ak + bk - deviation) / 2.0
		right = (ak + bk + deviation) / 2.0
		//fmt.Printf("  left: %f  right: %f\n", left, right)
		// Проверяем в какую часть попадает точка минимума 
		// слева от разбиения или справа и выбираем соответствующую точку
		// и переносим границу
		if g(data, left) <= g(data, right) {
		// Теперь правая граница отрезка локализации равна right
			bk = right;
		} else {
		// Теперь левая граница отрезка локализации равна left
			ak = left;
		}
		//fmt.Printf(" [%d] DICHO: %f epsilon: %f\n", k, (bk - ak), epsilon)
	}

	// точка как серединка полученного отрезочка a b
	// minimum point
  x_min = (ak + bk) / 2.0;
  return x_min
}


// Метод деления в пропорции "Золотого сечения" для нахождения минимума
func Goldensection(data ODO) float64 {
	// Номер шага
	var k int
	// Отклонени от точки деления отрезка влево, вправо
	var left float64
	var right float64
	// Точка минимума
	var x_min float64
	// критерий требуемой точности
	epsilon := data.GetEpsilon1()
	// Отрезок локализации минимума
	ak,bk := data.GetInterval()
	// функция g(x) оценки минимума в методах одномерной оптимизации на отрезке a,b 
	g := data.GetG()
	// Пропорция золотого сечения
	// L / m = m / n
	// L = 1 - это целый отрезок
	// m = (-1+sqrt(5))/2 = 0,618 - это бОльшая часть
	// n = L - m = 0,382 - это меньшая часть
	m := (-1.0 + math.Sqrt(5.0)) / 2.0
	n := 1.0 - m

	// Пока длина отрезка больше заданной точности
	niterations := data.GetMaxIterODO()
	for k = 1; (bk - ak) >= epsilon && k < niterations; k++ {
		// Деллим отрезок в пропрорции золотого сечения
		left = bk*n + ak*m
		right = ak*n + bk*m
		//fmt.Printf("  left: %f  right: %f\n", left, right)
		// Проверяем в какую часть попадает точка минимума 
		// слева от разбиения или справа и выбираем соответствующую точку
		// и переносим границу
		if g(data, left) <= g(data, right) {
		// Теперь правая граница отрезка локализации равна right
			bk = right
		} else {
		// Теперь левая граница отрезка локализации равна left
			ak = left
		}
		//fmt.Printf(" [%d] GOLDEN: %f epsilon: %f\n", k, (bk - ak), epsilon)
	}

	// точка как серединка полученного отрезочка a b
	// minimum point
	x_min = (ak + bk) / 2.0
	return x_min;
}

/*
  Градиентный спуск — метод нахождения локального экстремума (минимума или максимума) 
  функции с помощью движения вдоль градиента. Для минимизации функции в направлении 
  градиента используются методы одномерной оптимизации, например, метод золотого сечения 
  или дихотомии.
  Также можно искать не наилучшую точку в направлении градиента, а какую-либо лучше текущей.
  __
  \/F - оператор набла nabla F
  или другое обозначение grad F

  Градиентный спуск

  Алгоритм

  1.Задают начальное приближение и точность расчёта vec x[0],epsilon 
  2.Рассчитывают vec x[k+1]=vec x[k] - lambda[k] * nabla F(vec x[k]), 
   где lambda[k] = argmin_lambda F(vec x[k] - lambda * nabla F(vec x[k]))
  3.Проверяют условие остановки:
   Если |vec x[k+1] - vec x[k]| > epsilon 
     или |F(vec x[k+1]) - F(vec x[k])| > epsilon  
     или |nabla F(vec x[k+1])| > epsilon (выбирают одно из условий), 
   то k = k + 1 и переход к пункту 2.
   Иначе vec x = vec x[k+1] и останов.

 [https://ru.wikipedia.org/wiki/%D0%93%D1%80%D0%B0%D0%B4%D0%B8%D0%B5%D0%BD%D1%82%D0%BD%D1%8B%D0%B9_%D1%81%D0%BF%D1%83%D1%81%D0%BA]


  Метод наискорейшего спуска
	
  Алгоритм

 Шаг 1. Задать x[0], epsilon1 > 0,epsilon2 > 0, предельное число итераций М. 
   Найти градиент функции в произвольной точке. Определить частные производные функции f(x)
   grad f(x) = [ df(x)/x1,...,df(x)/dxn ]T(транспонированный вектор)
 Шаг 2. Положить k = 0.
 Шаг 3. Вычислить grad f(x[k]).
 Шаг 4. Проверить выполнение критерия окончания  ||grad f(x[k])|| < epsilon1 :
  а) если критерий выполнен, то x[0] = x[k], останов;
  б) если критерий не выполнен, то перейти к шагу 5.
 Шаг 5. Проверить выполнение неравенства k ≥ M:
  а) если неравенство выполнено, то x[0] = x[k], останов;
  б) если нет, то перейти к шагу 6.
 Шаг 6. Вычислить величину шага lambda[k], из условия
  F(lambda[k]) = f(x[k] - lambda[k] * grad f(x[k])) -> min_lamda[k].
 Шаг 7. Вычислить x[k+1] = x[k] - lambda[k] * grad f(x[k]).
 Шаг 8. Проверить выполнение условий ||x[k+1] - x[k]|| < epsilon2, ||f(x[k+1]) - f(x[k])|| < epsilon2:
  а) если оба условия выполнены при текущем значении k и k = k + 1, то расчет окончен, x[0] = x[k+1];
  б) если хотя бы одно из условий не выполнено, то положить k = k + 1 и перейти к шагу 3.

 [https://studfiles.net/preview/1874323/page:2/]

*/

// n-мерная норма
// условие остановки
func norma3(cur, next []float64) float64 {
	var sumSquares float64
	for i := 0; i < len(cur); i++ {
		sumSquares += (next[i] - cur[i])*(next[i] - cur[i])
	}
	return math.Sqrt(sumSquares)
}

// Метод наискорейшего спуска
// the method of steepest descent or stationary-phase method or saddle-point method
func SteepestDescent(data MDO) {
	var k int
	var lambda float64
	// П.1. Задают начальное приближение и точность расчёта vec x[0], epsilon
	// Шаг 1. Задать x[0], epsilon1 > 0, epsilon2 > 0, предельное число итераций М. 
	//  Найти градиент функции в произвольной точке. Определить частные производные функции f(x):
	//  grad f(x) = [ df(x)/x1,...,df(x)/dxn ]T(транспонированный вектор)
	var ninterations int = data.GetMaxIterMDO()
	args := data.GetX()
	epsilon := data.GetEpsilon2()
	// Начальное приближение u[0]
	u_cur := make([]float64, len(args))
	// Новое прилижение u[k]
	u_next := make([]float64, len(u_cur))

	copy(u_cur, args)

	// DEBUG
	//fmt.Println()
	//fmt.Println("## Исходная точка:")
	//fmt.Printf("  f(x) = %.4f\n", data.Function())
	//fmt.Printf("  x = [")
	//for _,x := range u_cur {
//		fmt.Printf("%.4f ", x)
//	}
//	fmt.Printf("]\n")
//	fmt.Println()
//	fmt.Println()
//	fmt.Println("## Приближения:")


	//Шаг 2. Положить k = 0
	stop := false
	for k = 0; k < ninterations && !stop ; k++ {
//		fmt.Printf("%d: ", k)
		// П.2. Рассчитывают vec x[k+1] = vec x[k] - lambda[k] * nabla F(vec x[k]),
		// где lambda[k]= argmin{lambda} F(vec x[k] - lambda * nabla F(vec x[k]))
		// Шаг 3. Вычислить grad f(x[k]).
		gradient := data.Grad()
		//fmt.Println("  gradient:", gradient)
		// Шаг 4. Проверить выполнение критерия окончания  ||grad f(x[k])|| < epsilon1 :
		//  а) если критерий выполнен, то x[0] = x[k], останов;
		//  б) если критерий не выполнен, то перейти к шагу 5.
		//
		// Шаг 5. Проверить выполнение неравенства k ≥ M:
		//  а) если неравенство выполнено, то x[0] = x[k], останов;
		//  б) если нет, то перейти к шагу 6
		//
		// Шаг 6. Вычислить величину шага lambda[k] из условия
		//  F(lambda[k]) = f(x[k] - lambda[k] * grad f(x[k])) -> min lambda[k]
		// Аргумент минимизации argmin по lambda(получить его реализацию)
		argmin := data.GetF()
		// Находим lambda[k] как минимум функции g(x[k]) на отрезке a = -10000, b = 100000
		lambda = argmin(data)
		//fmt.Println("  lambda:", lambda)
		// Вычисляем u[k] новое прилижение
		//  Шаг 7. Вычислить x[k+1] = x[k] - lambda[k] * grad f(x[k])
		for i,df_dxi := range gradient {
			u_next[i] = u_cur[i] - lambda * df_dxi
		}
		data.SetX(u_next)

		//DEBUG
//		fmt.Println()
//		fmt.Printf("  f(x) = %.4f\n", data.Function())
//		fmt.Printf("  x = [")
//		for _,x := range u_next {
//			fmt.Printf("%.4f ", x)
//		}
//		fmt.Printf("]\n")

		// П.3. Проверяют условие остановки:
		// Если |vec x[k+1] - vec x[k]| > epsilon 
		//  или |F(vec x[k+1]) - F(vec x[k])| > epsilon  
		//  или |nabla F(vec x[k+1])| > epsilon (выбирают одно из условий), 
		// то k = k + 1 и переход к П.2.
		// Иначе vec x = vec x[k+1] и останов.
		// 	Шаг 8. Проверить выполнение условий ||x[k+1] - x[k]|| < epsilon2, ||f(x[k+1]) - f(x[k])|| < epsilon2:
		//		а) если оба условия выполнены при текущем значении k и k = k - 1, то расчет окончен, x[0] = x[k+1], останов;
		//		б) если хотя бы одно из условий не выполнено, то положить k = k + 1 и перейти к шагу 3
		if k > 1 {
			// Проверяем условие остановки
			if norma3(u_cur,u_next) < epsilon {
				// останов
				stop = true
			}
		}

		copy(u_cur, u_next)
	}

	// DEBUG
//	fmt.Println()
//	fmt.Println("##* Точка минимума при epsilon:", epsilon)
//	data.SetX(u_cur)
//	fmt.Println(" f(x):", data.Function())
//	fmt.Printf("  x = [")
//	for _,x := range u_next {
//		fmt.Printf("%.4f ", x)
//	}
//	fmt.Printf("]\n")

	// получить минимум фуркции
	data.SetX(u_cur)
	data.SetY(data.Function())
}


//
// Хороший генератор соответствует следующим требованиям:
//
// 1) случайные числа равномерно распределены;
// 2) случайные числа независимы;
// 3) генерируемая последовательность имеет большой период повторения;
// 4) числа в последовательности различны, а не возможные перестановки их последовательности.
//


var (
	gRndSeed uint32 = 1 // последнее случайное число
	was int = 0 // была ли вычислена пара чисел
	r float64= 0 // предыдущее число
)
// Начиная с некоторого целого числа x0 =/= 0, задаваемого при помощи фукнции SRnd(),
// при каждом вызове функции Rnd() происходит вычисление нового псевдослучайного 
// числа на основе предыдущего.
func SRnd64(seed int64) {
	SRnd(uint32(seed))
}

func SRnd(seed uint32) {
	if seed == uint32(0) {
		gRndSeed = uint32(1)
	} else {
		gRndSeed = seed
	}
}
// Метод генерации случайных чисел основанный на эффекет переполнения 32-разрядных целых чисел
// возвращает равномерно распределённое случайное число
func RndU() uint32 {
	gRndSeed = gRndSeed * uint32(1664525) + uint32(1013904223)
	return gRndSeed
}
// генерировать челое число из диапазона
// с типами надо подумать...
//TODO: надо потестировать! 
func RndBetweenU(bottom, top int) (result int) {
	// формула генерации случайных чисел по заданному диапазону
	// где bottom - минимальное число из желаемого диапазона
	// top - верхнаяя граница, ширина выборки
	rnd := int(RndU())
	//rndBetween := bottom + rnd % top - bottom
	div := rnd % top
	diff := top - div
	//fmt.Printf("Result: %d  rnd: %d  botton: %d  top: %d  div: %d  diff: %d\n", rndBetween, rnd, bottom, top, div, diff)
	if diff > bottom {
		result = bottom + div
	} else {
		result = div
	}
	return
}
// Алгоритм для генерирования вещественных чисел основанны на данном методе
func Rnd() float64 {
	// константа 0xffffffff это максимальное беззнаковое целое 2^32 - 1 
	// в шестнадцатирчной системе счисления
	return float64(RndU()) / float64(0xffffffff)
}

// Для генерации нормальлного распределённого случайного числа с нулевым средним
// и единичной волатильностью служит метод Бокса-Миллера.
// Перейдём от равномерно распределённоый на интервале [0..1] чисел x1 и x2 
// к переменным у1 = sqrt(-2ln(x1))*cos(2pi()x2), y2 = sqrt(-2ln(x1))*sin(2pi()x2).
// Количество чисел, попавших в некоторую область двухмерного пространства omega,
// определяется двойным интегралом. При замене пременных в интеграле объём умножается наякобиан:
//intergral(min = omega,max = +oo) dx1 dx2 =
//                                   || dx1/dy1 dx1/dy2 ||
//= integral(min = omega, max = +oo) ||                 || dy1 dy2 =
//                                   || dx2/dy1 dx2/dy2 ||
//
//= integral(min = omega, max = +oo) 1/sqrt(2pi()) exp(-y1^2/2) * 1/sqrt(2pi()) exp(-y1^2/2) dy1 dy2.
//
// Таким образом, переменные y1 и y2 являются независимыми(интегралы расщепляются) 
// и имеют нормальные распределения.
// Функция cos и sin вычисляются достаточно долго. 
// Чтобы избежать работы с ними, воспользуемся следующеим приёмом.
//
// Численный метод реализующий генерацию нормально распределённого случайного числа по Боксу-Миллеру.
// Выберем область интегрирования в виде круга с единичным радиусом и центром в начале координат.
// Будем случайным образом равномерно заполнять его точками.
// Пусть v1, v2 - координаты точки внутри круга v1^2 + v2^2 = r^2 < 1.
// В полярных координатах v1 = r*cos alpha, v2 = r*sin alpha.
// Так как v1, v2 распределены равномерно, то и полярный угол alpha будет равномерно
// распределён в интервале [0..2pi()].
// Поэтому для вычисления значения cos и sin можно воспользоваться соотношениями v1/r, v2/r.
//
// Гауссовы случайные числа с нулевым средним и единичной дисперсией 
func RndG() float64 {
	// если уже есть случаное число, то отдать его и сбросить флаг
	if (was != 0) {
		was = 0
		return r
	}

	var s float64 = 0
	var v1 float64
	var v2 float64
	for ;s >= 1.0 || s == 0; { // ждём попадания в круг
		v1 = 2 * Rnd() - 1 // точка в квадрате [-1..1]
		v2 = 2 * Rnd() - 1
		s = v1 * v1 + v2 * v2 // квадрат расстояния от центра
	}

	was = 1
	r = v1 * math.Sqrt (-2 * math.Log(s)/s) // первое число (запомнили)
	return v2 * math.Sqrt (-2 * math.Log(s)/s) // второе число(вернули)
}



// Метод вычисления приближённого значения факториала по формуле Стирлинга(Муавра — Стирлинга), 
// позволяющей вычислять факториал при больших n. Относительная ошибка уже при n = 10 становится меньше 1%
//
// sqrt(2*pi*n)(n/exp)^n
//
func Factorial(n float64) float64 {
	if n == float64(0) {
		return float64(1)
	} else if n == float64(1) {
		return float64(1)
	} else {
		//FIXME: return math.Sqrt2 * math.SqrtPi * float64(n) * math.Pow(float64(n)/math.E,float64(n))
		return math.Sqrt(2.0 * math.Pi * n) * math.Pow(n/math.E, n)
	}
}


// Число перестановок(сочетаний) из n элементов по k штук
// в лоб по формуле
//
// |n|      n!
// | | = --------
// |k|   k!(n-k)!
//
func PermOfNbyK(n,k float64) (perm float64) {
	perm = Factorial(n)/(Factorial(k)*Factorial(n-k))
	return
}



/*
TODO: Метод стохастической оптимизации.
Генетический алгоритм
1.Задают начальное приближение или исходную популяцию и точность расчёта vec x[0], epsilon
2.Производят оценку пригодности популяции, вычисляя некоторую функцию дающую количественные оценки решений в поколении
F(vec x[k])
3.Проверяют условия остановки, хотябы одно решение в текущем поколении удовлетворяет условию
F(x) < epsilon или наоборот F(x) > epsilon(альтренатива)
Если условие выполнено,
vec x = vec x[k+1] и останов
Иначе переход к пункту 4
4.Произвоят отбор наиболее пригодных решений(особей) в текущем поколении. Обычно это какая-то часть популяции.
vec z[k] = S(vec x[k])
5.Из полученного подмножества наиболее пригодных решений при помощи генетических операторов формируют новое поколение
vec x[k+1]= R(vec z[k])
k = k + 1 и переход к пункту 2

Шаг 1. Задать x[0], epsilon1 > 0, epsilon2 > 0, предельное число итераций М. 
        Найти множество произвольных исходных решений.
        initialize f(x) = [ x1,x2,...,xn ]T(транспонированный вектор)
Шаг 2. Положить k = 0.
Шаг 3. Вычислить функцию пригодности F([k]).
Шаг 4. Проверить выполнение критерия окончания  ||F([k])|| < epsilon1 (или > epsilon1):
    а) если критерий выполнен, то x[0] = x[k], останов;
    б) если критерий не выполнен, то перейти к шагу 5.
Шаг 5. Проверить выполнение неравенства k ≥ M:
    а) если неравенство выполнено, то x[0] = x[k], останов;
    б) если нет, то перейти к шагу 6.
Шаг 6. Произвести отбор наболее пригодных решений, из условия.
       z[k] = S(x[k]), где F(x[k]) -> min (или max) 
Шаг 7. Выполнить операцию рекомбинации. Сформировать новое множество решений из наиболее пригодных при помощи генетических операторов.
       x[k+1] = R(z[k])
Шаг 8.TODO: П.3 Проверить условие остановки:
		 Если |vec x[k+1] - vec x[k]| > epsilon 
		  или |F(vec x[k+1]) - F(vec x[k])| > epsilon  
		  или |nabla F(vec x[k+1])| > epsilon (выбирают одно из условий), 
		 то k = k + 1 и переход к П.2.
		 Иначе vec x = vec x[k+1] и останов.
		 	Шаг 8. Проверить выполнение условий ||x[k+1] - x[k]|| < epsilon2, ||f(x[k+1]) - f(x[k])|| < epsilon2:
				а) если оба условия выполнены при текущем значении k и k = k - 1, то расчет окончен, x[0] = x[k+1], останов;
				б) если хотя бы одно из условий не выполнено, то положить k = k + 1 и перейти к шагу 3

Некоторые полезные мысли, термины и определеиня
https://studopedia.org/1-12570.html
*/

/*
// 
// Genetic Algorithm
//

// создать популяцию численности N
populationSize := N 
pop := NewPop(populationSize)

// сформировать исходную популяцию или начальное приближение
pop.FoundingFathers()

// максимальное число итераций
var niterations = 10
for i := 0; i < niterations && !pop.Done(); i++ {

	// Estimate population fitnesses
	pop.EvaluateFitness()

	// There will be selection of the fittest
	pop.SelectFittestSurvivors()

	// Spawn new generation from the most fittest
	pop.Recombine()
}
// Get result
pop.Result()
*/

//
/*
// Алгоритм Фишера – Йетса (Современная версия)
// Алгоритм Саттоло
//
// https://ru.wikipedia.org/wiki/%D0%A2%D0%B0%D1%81%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%A4%D0%B8%D1%88%D0%B5%D1%80%D0%B0_%E2%80%94_%D0%99%D0%B5%D1%82%D1%81%D0%B0
//
// arr - массив для перестановки, N - количество элементов в массиве
func shuffleSattolo(arr *[]int) {
  N := len(*arr)

  // shake the generator!
  SRnd64(time.Now().Unix())

  for i := N-1; i > 1; i-- {
    j := RndBetweenU(0, i-1) // 0 <= j <= i-1
    (*arr)[j],(*arr)[i] = (*arr)[i],(*arr)[j]
  }
}

// arr - массив для перестановки, N - количество элементов в массиве
func shuffleFisherYates(arr *[]int) {
  N := len(*arr)

  // shake the generator!
  SRnd64(time.Now().Unix())

  for i := N-1; i >= 1; i-- {
    j := RndBetweenU(0, i+1)
    (*arr)[j],(*arr)[i] = (*arr)[i],(*arr)[j]
  }
}




func main() {
  var arr1 []int = []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
  var arr2 []int = []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }

  fmt.Println("source:              ",arr1)
  shuffleFisherYates(&arr1)
  fmt.Println("Fisher-Yates shuffle:",arr1)
  fmt.Println()
  fmt.Println("source:         ",arr2)
  shuffleSattolo(&arr2)
  fmt.Println("Sattolo shuffle:",arr2)
  fmt.Println()
}
*/


/*
Формулы Эрланга

	// расчитать размер очереди для взаимодействия популяций с целью получения гибридов
	// и среднее число загруженных приборов обслуживания
	// эти значения общие для всех популяций
	// поток заявок, здесь это запрос особи для гибридизации
	// или изъятие из общей очереди одного элемента
	lambda := float64(hybridize) // тест при лямбдя = 11
	// поток обслуживания, здесь это размер буфера, 
	// количество ячеек для особей
	mu := 1.0
	alpha := lambda / mu
	// количесво приборов обслуживания, здесь это ячейки т.к. одна ячейка обслуживает одну заявку mu = 1
	// тогда получим что количество обслуживающих приборов равно среднему числу завок lambda
	n := lambda 
	// расчитаем вероятность отсутствия заявок P0
	// для этого вычислим сумму
	sum := 0.0
	for k := 0.0; k < lambda; k++ {
		//p := math.Pow(alpha, k)
		//f := Factorial(k)
		sum += math.Pow(alpha, k)/Factorial(k)
		//fmt.Printf(" [%.0f]: p: %f  f: %f  p/f: %f\n", k, p, f, p/f)
	}
	P0 := 1 / sum
	Pn := math.Pow(alpha, n)/Factorial(n) * P0
	// поток отказов обслуживания
	refusal := lambda * Pn
	// вероятность обслуживания(или качество обслуживания)
	Q := 1 - Pn
	// среднее кличество занятых приборв
	averageLoad := lambda * Q
	// размер буфера 
	queueSize := averageLoad * float64(workers)
	// создать буфер полученного размера
	queue = make(chan *Chromosome, int(queueSize))

	fmt.Printf("  lambda: %f\n", lambda)
	fmt.Printf("  mu: %f\n", mu)
	fmt.Printf("  alpha: %f\n", alpha)
	fmt.Printf("  n: %f\n", n)
	fmt.Printf("  Sum: %f\n", sum)
	fmt.Printf("  P0: %f\n", P0)
	fmt.Printf("  Pn: %f\n", Pn)
	fmt.Printf("  Refusal: %f\n", refusal)
	fmt.Printf("  Q: %f\n", Q)
	fmt.Printf("  Avg Load: %f\n", averageLoad)
	fmt.Printf("  QSz: %f\n", queueSize)
*/


// 
// Производящие функции
// TODO: http://www.genfunc.ru/theory/intro/
//

